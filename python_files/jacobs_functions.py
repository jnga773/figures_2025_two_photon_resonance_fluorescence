#==============================================================================#
#                     JACOB'S PYTHON FUNCTIONS WEEWEEWOOWOO                    #
#==============================================================================#
# This Python module [jacobs_functions.py] contain functions/routines for a
# bunch of different things like calculating Fourier transforms, to setting
# figure dimensions.
#
# This module contains the following functions:
# - spectrum
#   Calculates the incoherent power spectrum for an input first-order
#   correlation function.
#
# - shiftedColorMap
#   Shifts the colour map so the centre is at a specified value.
#
# - stretch_boundary_norm
#   Stretches the boundaries of a colourmap to make it continuous along the
#   defined boundary norms.

#------------------------------------------------------------------------------#
def spectrum(tau_input, corr_input, pos=None, norm="peak"):
    """
    Calculate the power spectrum corresponding to a two-time correlation
    function using FFT.

    Parameters
    ----------
    tau_input : array_like
        list of times generated by code.
    corr_input : like
        list of imaginary first-order correlation values.
    pos : conditional
        Used for contour plots to define positive or negative frequencies.
        None - Both positive and negative frequencies.
        False - Negative frequencies.
        True - Positive frequencies.
    norm : string
        Type of normalisation used.
        "integral" - Normalise such that the area under the spectrum is one.
        "peak" - Normalise such that the maximum peak is one.
        "None" - No normalisation

    Returns
    -------
    spec_output : array_like
        Intensity spectrum of first-order correlation.
    wlist_output : array_like
        List of frequencies
    """
    from numpy.fft import fft, fftshift, fftfreq
    from numpy import where, mean, zeros, pi, array
    from numpy import sum as npsum
    from numpy import max as npmax
    # Shift the arrays so they are arranged from negative to positive freq
    fft = fft(corr_input)#, norm='ortho')
    fft = fftshift(fft)
    freq = fftfreq(tau_input.shape[0], tau_input[1]-tau_input[0])
    freq = fftshift(freq)
    # As the central peak is a delta function, we ignore the plot for w=0. To
    # do this we find the index in wlist where it is equal to 0.0, ignore it,
    # and create a new list excluding this value.
    if pos is True:
        indices = where(freq > 0.0)[0]
    elif pos is False:
        indices = where(freq < 0.0)[0]
    elif pos is None:
        indices = where(freq != 0.0)[0]
    # Remove zero frequency term
    spec_output = fft[indices]
    # Take only the real part
    spec_output = spec_output.real
    # take away non zero tails
    spec_output = spec_output - mean(spec_output[0])
    wlist_output = freq[indices] # wlist is in terms of FFT frequencies
    wlist_output = array(wlist_output) * 2 * pi
    if norm == "integral":
        if npmax(spec_output) == 0.0:
            spec_output = spec_output
        else:
            normalise = npsum(spec_output) * (wlist_output[1] - wlist_output[0])
            spec_output = spec_output / normalise
    elif norm == "peak":
        if npmax(spec_output) == 0.0:
            spec_output = zeros(len(wlist_output))
        else:
            spec_output = spec_output / npmax(spec_output)
    elif norm == "none":
        spec_output = spec_output
    return spec_output, wlist_output

#------------------------------------------------------------------------------#
def shiftedColorMap(cmap, start=0.0, midpoint=0.5, stop=1.0, name='shiftedcmap'):
    '''
    Function to offset the "center" of a colormap. Useful for
    data with a negative min and positive max and you want the
    middle of the colormap's dynamic range to be at zero.

    Parameters
    ----------
    cmap : matplotlib colourmap
      The matplotlib colormap to be altered
    start : float
        Offset from lowest point in the colormap's range. Defaults to 0.0
        (no lower offset). Should be between 0.0 and `midpoint`.
    midpoint : float
        The new center of the colormap. Defaults to 0.5 (no shift). Should be
        between 0.0 and 1.0. In general, this should be 
                1 - vmax / (vmax + abs(vmin)) .
        For example if your data range from -15.0 to +5.0 and you want the
        centre of the colormap at 0.0, `midpoint`, should be set to 
                1 - 5/(5 + 15)) or 0.75 .
    stop : float
        Offset from highest point in the colormap's range. Defaults to 1.0
        (no upper offset). Should be between `midpoint` and 1.0.
    name : string
        The name of the new colormap.

    Returns
    -------
    norm_out : array_like
        Renormalised colour map.
    '''
    from matplotlib import colors
    cdict = {
        'red': [],
        'green': [],
        'blue': [],
        'alpha': []
    }

    # regular index to compute the colors
    reg_index = np.linspace(start, stop, 257)

    # shifted index to match the data
    shift_index = np.hstack([
        np.linspace(0.0, midpoint, 128, endpoint=False), 
        np.linspace(midpoint, 1.0, 129, endpoint=True)
    ])

    for ri, si in zip(reg_index, shift_index):
        r, g, b, a = cmap(ri)

        cdict['red'].append((si, r, r))
        cdict['green'].append((si, g, g))
        cdict['blue'].append((si, b, b))
        cdict['alpha'].append((si, a, a))

    newcmap = colors.LinearSegmentedColormap(name, cdict)
    plt.register_cmap(cmap=newcmap)

    return newcmap

#------------------------------------------------------------------------------#
def stretch_boundary_norm(boundaries_in, ncolours_in=256):
    """
    Stretch the boundaries of a colourmap to make it continuous.

    Parameters
    ----------
    boundaries_in : array_like
        List of boundaries.
    ncolours_in : int
        Number of colours in the colourmap (Default: 256).

    Returns
    -------
    norm_out : object
        Renormalised colourmap.
    """
    from matplotlib.colors import BoundaryNorm
    from numpy import linspace, interp
    
    # Number of boundary points
    N_bounds = len(boundaries_in)
    # Stretch the bounds so colourmap is continuous-esque
    stretched_bounds = interp(linspace(0, 1, ncolours_in+1), linspace(0, 1, N_bounds),
                              boundaries_in)
    
    # Return the norm
    norm_out = BoundaryNorm(stretched_bounds, ncolors=ncolours_in)
    
    return norm_out